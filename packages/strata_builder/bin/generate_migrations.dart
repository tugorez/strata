#!/usr/bin/env dart

import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:strata_builder/src/utils/migration_parser.dart';

/// Generates migrations.dart from SQL migration files.
///
/// This script follows the protobuf pattern:
///   migrations/*.sql  ‚Üí  CLI script  ‚Üí  lib/migrations.dart (committed)
///
/// The generated file is NOT a part file - it's a standalone Dart file
/// that should be committed to source control.
void main(List<String> arguments) async {
  final migrationsDir = arguments.isNotEmpty ? arguments[0] : 'migrations';
  final outputFile = arguments.length > 1
      ? arguments[1]
      : 'lib/migrations.dart';

  print('üîç Scanning for migrations in $migrationsDir/...');

  final dir = Directory(migrationsDir);
  if (!dir.existsSync()) {
    stderr.writeln('‚ùå Error: Directory $migrationsDir does not exist');
    exit(1);
  }

  // Find all .sql files
  final sqlFiles =
      dir
          .listSync()
          .whereType<File>()
          .where((f) => f.path.endsWith('.sql'))
          .toList()
        ..sort((a, b) => p.basename(a.path).compareTo(p.basename(b.path)));

  if (sqlFiles.isEmpty) {
    stderr.writeln('‚ùå No migration files found in $migrationsDir/');
    exit(1);
  }

  print('‚úì Found ${sqlFiles.length} migration file(s)');

  // Generate the Dart code
  final buffer = StringBuffer();
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by bin/generate_migrations.dart');
  buffer.writeln();
  buffer.writeln("import 'package:strata_sqlite/strata_sqlite.dart';");
  buffer.writeln();
  buffer.writeln(
    '/// Auto-generated migrations from the migrations/ directory.',
  );
  buffer.writeln('class Migrations {');
  buffer.writeln('  static List<SqlMigration> get all => [');

  for (final file in sqlFiles) {
    final fileName = p.basename(file.path);

    // Parse filename to extract version and name
    final metadata = MigrationParser.parseFilename(fileName);
    if (metadata == null) {
      print(
        '‚ö†Ô∏è  Skipping $fileName (invalid format, expected YYYYMMDDHHmmss_name.sql)',
      );
      continue;
    }

    final version = metadata['version'] as int;
    final name = metadata['name'] as String;

    // Parse the SQL file
    final content = await file.readAsString();
    final sections = MigrationParser.parseMigrationFile(content);
    final upStatements = sections['up'] ?? [];
    final downStatements = sections['down'];

    if (upStatements.isEmpty) {
      print('‚ö†Ô∏è  Warning: $fileName has no up statements');
    }

    buffer.writeln('        SqlMigration(');
    buffer.writeln('          version: $version,');
    buffer.writeln('          name: ${MigrationParser.escapeString(name)},');
    buffer.writeln('          upStatements: [');
    for (final statement in upStatements) {
      buffer.writeln('            ${MigrationParser.escapeString(statement)},');
    }
    buffer.writeln('          ],');

    if (downStatements != null && downStatements.isNotEmpty) {
      buffer.writeln('          downStatements: [');
      for (final statement in downStatements) {
        buffer.writeln(
          '            ${MigrationParser.escapeString(statement)},',
        );
      }
      buffer.writeln('          ],');
    }

    buffer.writeln('        ),');

    print('  ‚úì $fileName');
  }

  buffer.writeln('      ];');
  buffer.writeln('}');

  // Write the output file
  final output = File(outputFile);
  output.parent.createSync(recursive: true);
  await output.writeAsString(buffer.toString());

  print('');
  print('‚ú® Generated $outputFile');
}
