import 'package:strata/src/query.dart';

/// The abstract contract for a database-specific adapter.
///
/// The `StrataRepo` delegates all direct database operations (CRUD and
/// connection management) to an instance of a `StrataAdapter`. This decouples
/// the public repository API from the underlying database technology, allowing
/// `StrataRepo` to remain database-agnostic.
///
/// ## Separation of Concerns
///
/// This adapter is responsible for **data access** only. Schema management
/// (migrations) is handled separately by migration-specific classes like
/// `SqlMigrationRunner`, following the Single Responsibility Principle.
abstract class StrataAdapter {
  /// Initializes the adapter and opens the database connection.
  ///
  /// This method should be called before any other database operations.
  /// It ensures that the underlying connection is ready to accept commands.
  Future<void> initialize();

  /// Closes the database connection and releases any resources.
  Future<void> close();

  /// Executes a [query] expected to return at most one record.
  ///
  /// The adapter is responsible for translating the abstract [Query] object
  /// into a database-specific query (e.g., a SQL string with bindings).
  ///
  /// Returns a `Map` representing the raw database record, or `null` if no
  /// record is found. The `StrataRepo` will then map this to a `Schema` object.
  Future<Map<String, dynamic>?> getOne(Query query);

  /// Executes a [query] and returns a list of matching records.
  ///
  /// The adapter is responsible for translating the abstract [Query] object
  /// into a database-specific query.
  ///
  /// Returns a `List` of `Map`s, where each map is a raw database record.
  /// The `StrataRepo` will map this list to `Schema` objects.
  Future<List<Map<String, dynamic>>> getAll(Query query);

  /// Inserts a new record into the specified [table] with the given [changes].
  ///
  /// The [changes] map is derived from a valid `Changeset` and contains
  /// sanitized data ready for insertion.
  ///
  /// Must return a `Map` representing the fully inserted record, including any
  /// values generated by the database (like a primary key).
  Future<Map<String, dynamic>> insert(
    String table,
    Map<String, dynamic> changes,
  );

  /// Updates records matching the [query] with the provided [changes].
  ///
  /// The adapter must filter records based on the [query]'s criteria and apply
  /// the [changes] to all matching records.
  ///
  /// Must return a `List` of `Map`s representing the complete state of all
  /// updated records after the operation.
  Future<List<Map<String, dynamic>>> update(
    Query query,
    Map<String, dynamic> changes,
  );

  /// Deletes all records matching the given [query].
  ///
  /// Returns the number of records deleted.
  Future<int> delete(Query query);

  /// Begins a database transaction.
  ///
  /// All subsequent operations will be part of this transaction until
  /// [commit] or [rollback] is called.
  ///
  /// Transactions ensure atomicity: either all operations succeed together,
  /// or none of them take effect. This is essential for maintaining data
  /// consistency when performing multiple related operations.
  ///
  /// Example:
  /// ```dart
  /// await adapter.beginTransaction();
  /// try {
  ///   await adapter.insert('users', userData);
  ///   await adapter.insert('posts', postData);
  ///   await adapter.commit();
  /// } catch (e) {
  ///   await adapter.rollback();
  ///   rethrow;
  /// }
  /// ```
  Future<void> beginTransaction();

  /// Commits the current transaction.
  ///
  /// Makes all changes performed since [beginTransaction] permanent.
  /// After commit, the transaction is complete and a new one must be
  /// started for subsequent transactional operations.
  Future<void> commit();

  /// Rolls back the current transaction.
  ///
  /// Discards all changes performed since [beginTransaction].
  /// The database state will be restored to what it was before the
  /// transaction began.
  Future<void> rollback();
}
