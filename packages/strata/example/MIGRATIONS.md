# Strata Migrations Example

This example demonstrates how to use the Strata migration system.

## Overview

Strata migrations follow the **protobuf pattern**:
```
migrations/*.sql  →  CLI script  →  lib/migrations.dart (committed)
```

This is similar to how protobuf works:
- `protos/*.proto` → `protoc` → `lib/src/*.pb.dart` (committed)

**Why this pattern?**
- SQL files are the source of truth
- Generated Dart file is derived output that gets committed
- No `build_runner` needed for migrations
- Fast, explicit generation when you modify migrations

## Setup

1. Create a migrations directory in your project root:
```bash
mkdir migrations
```

2. Create your first migration:
```bash
dart run strata_builder:create_migration create_users_table
```

3. Edit the generated SQL file (e.g., `migrations/20241115100000_create_users_table.sql`):
```sql
-- Migration: create_users_table
-- Timestamp: 20241115100000

-- @Up()
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_users_email ON users(email);

-- @Down()
DROP INDEX IF EXISTS idx_users_email;
DROP TABLE IF EXISTS users;
```

**Migration Naming:** Migrations use timestamp-based filenames (YYYYMMDDHHmmss) following Ecto's convention:
- `20241115100000_create_users_table.sql`
- `20241115110000_create_posts_table.sql`
- `20241115120000_add_user_status_column.sql`

This prevents merge conflicts when multiple developers create migrations.

The `-- @Up()` annotation marks statements to apply the migration.
The `-- @Down()` annotation (optional) marks statements to rollback the migration.

4. Generate the Dart migrations file:
```bash
dart run strata_builder:generate_migrations
```

This will generate `lib/migrations.dart` with all your migrations. **Commit this file to source control.**

## Usage in Code

```dart
import 'package:strata/strata.dart';
import 'package:strata_sqlite/strata_sqlite.dart';
import 'package:your_app/migrations.dart';  // Generated & committed

Future<void> main() async {
  // Initialize the adapter
  final adapter = SqliteAdapter(path: 'app.db');
  await adapter.initialize();

  // Create a migration runner using the adapter's executor
  // Note: SqlMigrationRunner is in strata_sqlite because it's SQL-specific
  final runner = SqlMigrationRunner(execute: adapter.executor);

  // Run all pending migrations
  await runner.run(Migrations.all);

  // Now your database is up to date!
  final repo = StrataRepo(adapter: adapter);
  // ... use the repo
}
```

## Creating Multiple Migrations

```bash
# Create initial schema
dart run strata_builder:create_migration create_users_table

# Add more tables
dart run strata_builder:create_migration create_posts_table

# Add columns or indexes
dart run strata_builder:create_migration add_user_status_column

# Generate the Dart code
dart run strata_builder:generate_migrations

# Commit both SQL files and the generated Dart file
git add migrations/ lib/migrations.dart
```

## Generated Code

After running `generate_migrations`, you'll get a file like this:

```dart
// lib/migrations.dart
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:strata_sqlite/strata_sqlite.dart';

class Migrations {
  static List<SqlMigration> get all => [
    SqlMigration(
      version: 20241115100000,
      name: 'create_users_table',
      upStatements: [
        'CREATE TABLE users (...)',
        'CREATE INDEX idx_users_email ON users(email)',
      ],
      downStatements: [
        'DROP INDEX IF EXISTS idx_users_email',
        'DROP TABLE IF EXISTS users',
      ],
    ),
    // ... more migrations
  ];
}
```

## Migration Tracking

The `SqlMigrationRunner` automatically:
- Creates a `schema_migrations` table to track which migrations have been applied
- Only runs migrations that haven't been run yet
- Records the version, name, and timestamp of each migration
- Runs migrations in order by version number

## Best Practices

1. **Never modify existing migrations** - Once a migration is in version control and has been run, create a new migration to make changes
2. **Use descriptive names** - `add_user_email_index` is better than `migration2`
3. **One logical change per migration** - This makes it easier to understand and rollback if needed
4. **Test migrations** - Always test migrations on a copy of your production database before deploying
5. **Keep migrations small** - Smaller migrations are easier to review and less risky
6. **Commit the generated file** - The `lib/migrations.dart` file should be committed to source control

## Directory Structure

```
your_project/
├── lib/
│   ├── migrations.dart             # Generated by CLI, committed to source control
│   └── main.dart
├── migrations/                      # Your SQL migration files (source of truth)
│   ├── 20241115100000_create_users_table.sql
│   ├── 20241115110000_create_posts_table.sql
│   └── 20241115120000_add_user_status.sql
├── pubspec.yaml
└── build.yaml
```